package app

import (
	"fmt"
	"os"
	"strings"

	"github.com/spf13/cobra"

	"github.com/eluv-io/ecobra-go/bflags"
	"github.com/eluv-io/errors-go"
)

type SamplePrinter interface {
	// Print receives a command line sample iff the execution failed as expected
	// by the sample.ExpectRun field.
	// cmdPath: path to the command
	// sample: the sample that was used or nil (if no flags were used).
	// cmdLine: the command line
	Print(cmdPath []string, sample *InputSample, cmdLine string)

	// Example receives an echo of the example command line before sending it to
	// the cobra Execute function (except the first call that just reports the
	// number of examples found)
	Example(cmdLine string)

	// ExamplesSummary receives the count of commands with a run method, the
	// number of them with an example, the number of examples
	ExamplesSummary(withRun, withEx, exCount int) error
}

type InputSample struct {
	ExpectFail      bool
	ExpectedFailure string
	Input           interface{}
	args            []string
}

type CmdValidator interface {

	// InputSamples provides samples of the given interface for the given command
	InputSamples(cmdPath []string, in interface{}) []*InputSample

	// Validate validates values received from a command line execution.
	// The function is called only if the input is not rejected by cobra.
	//
	// cmdPath: the command 'path'
	// val: one of the InputSample that was produced by InputSamples
	// in: the 'input' value for the command defined in the spec and altered
	//     by the command line execution
	Validate(cmdPath []string, val *InputSample, in interface{}) error

	// ValidateError validates the error received for the given input sample is
	// legitimate
	ValidateError(cmdPath []string, val *InputSample, err error) error
}

type CmdSampler interface {
	ValidateInputSamples() error
	ValidateExamples() error
}

func NewCmdSampler(app *App, printer SamplePrinter, validator CmdValidator) CmdSampler {
	if printer == nil {
		panic(errors.E("NewCmdSampler", errors.K.Invalid,
			"reason", "sample printer must not be nil"))
	}
	return &cmdSampler{
		app:       app,
		printer:   printer,
		validator: validator,
	}
}

//
// ----- impl -----
//
const (
	cmdLineArr  = "$cmdLine"
	inputSample = "$inputSample"
)

type cmdSamples struct {
	cmdPath []string
	samples []*InputSample
}

type cmdSampler struct {
	app       *App          // the application
	printer   SamplePrinter // print command line samples
	validator CmdValidator  // called to validate samples
	samples   []*cmdSamples // the samples to run
}

// runInputSample is called when validating 'input samples' generated by the
// validator
func (s *cmdSampler) runInputSample(ctx *CmdCtx, in interface{}) error {
	v, ok := ctx.Get(inputSample)
	if !ok {
		return errors.E("runSample", errors.K.NotExist,
			"reason", "missing valid input")
	}
	cmdLine, ok := ctx.Get(cmdLineArr)
	if !ok {
		return errors.E("runSample", errors.K.NotExist,
			"reason", "missing command line")
	}
	sample := v.(*InputSample)
	if sample.ExpectFail {
		return errors.E("runSample", errors.K.Invalid,
			"reason", "did not expect to run",
			"sample", sample)
	}
	return s.validator.Validate(cmdLine.([]string), sample, in)
}

// runExample is called when running example. It does not do anything.
func (s *cmdSampler) runExample(ctx *CmdCtx, in interface{}) error {
	return nil
}

// runExample is called when running example. It does not do anything.
func (s *cmdSampler) runExampleOneParam(ctx *CmdCtx) error {
	return nil
}

func (s *cmdSampler) ValidateInputSamples() error {
	e := errors.Template("ValidateInputSamples")
	if s.validator != nil {
		// go through the app and replace the run func with our 'runSample'
		s.replaceRun(s.app.spec.CmdRoot, true)
	}

	// construct the cobra commands
	root, err := s.app.Cobra()
	if err != nil {
		return e(err)
	}
	err = s.cmdSamples(root, []string{})
	if err != nil {
		return e(err)
	}
	if s.validator == nil {
		// no samples to show since no validator provided them ...
		return nil
	}
	return s.runSamples()
}

func (s *cmdSampler) replaceRun(c *Cmd, inputSample bool) {
	if !c.RunE.IsNil() {
		c.RunE.name = ""
		if inputSample {
			c.RunE.fn = s.runInputSample
			if c.Input == nil {
				c.RunE.fn = s.runExampleOneParam
			}
		} else {
			c.RunE.fn = s.runExample
			if c.Input == nil {
				c.RunE.fn = s.runExampleOneParam
			}
		}
	}
	for _, ch := range c.SubCommands {
		s.replaceRun(ch, inputSample)
	}
}

func commandLine(f bflags.Flagger, cmdPath []string, in *InputSample) ([]string, error) {
	c := &cobra.Command{}
	err := bflags.BindCustom(c, f, in.Input)
	if err != nil {
		return nil, err
	}
	kflags, err := bflags.GetCmdFlagSet(c)
	if err != nil && !errors.IsNotExist(err) {
		return nil, err
	}
	result := cmdPath
	argset, err := bflags.GetCmdArgSet(c)
	if err != nil && !errors.IsNotExist(err) {
		return nil, err
	}
	for _, v := range kflags {
		if v.Hidden || v.Value == nil {
			continue
		}
		result = append(result, v.CmdString()...)
	}
	if argset != nil {
		for _, fl := range argset.Flags {
			result = append(result, fl.CmdString()...)
		}
	}
	return result, nil
}

func (s *cmdSampler) samplesFor(c *cobra.Command, cmdPath []string) (*cmdSamples, error) {
	v, ok := bflags.GetCmdInput(c)
	if !ok {
		s.printer.Print(cmdPath, nil, strings.Join(cmdPath, " "))
		// no input provided ignore otherwise
		return nil, nil
	}

	// no validator: only flags bindings occurring without error are tested
	if s.validator == nil {
		return nil, nil
	}

	ins := s.validator.InputSamples(cmdPath, v)
	if len(ins) == 0 {
		// no sample provided either raise an error or return silently ?
		// ignore for now
		return nil, nil
	}
	result := &cmdSamples{
		cmdPath: cmdPath,
		samples: make([]*InputSample, 0),
	}
	for _, in := range ins {
		osArgs, err := commandLine(s.app.customFlags, cmdPath, in)
		if err != nil {
			return nil, err
		}
		in.args = osArgs
		result.samples = append(result.samples, in)
	}
	return result, nil
}

func (s *cmdSampler) runSamples() error {
	e := errors.Template("runSamples")
	for _, sample := range s.samples {
		cmdPath := sample.cmdPath
		for _, csample := range sample.samples {
			// reset the commands for each execution
			s.app.root = nil

			root, err := s.app.Cobra()
			if err != nil {
				return e(err)
			}
			os.Args = csample.args

			var ctx *CmdCtx
			cc, ok := bflags.GetCmdCtx(root)
			if ok {
				ctx, _ = cc.(*CmdCtx)
			}
			if ctx == nil {
				ctx = NewCmdCtx()
			}
			ctx.Set(inputSample, csample)
			ctx.Set(cmdLineArr, cmdPath)
			ctx.Set(CmdValidate, s.validator)
			bflags.SetCmdCtx(root, ctx)

			s.printer.Print(cmdPath, csample, strings.Join(csample.args, " "))
			err = root.Execute()
			if err != nil {
				if csample.ExpectFail {
					err = s.validator.ValidateError(cmdPath, csample, err)
				}
				if err != nil {
					return e(err, "path", cmdPath,
						"args", strings.Join(csample.args, " "),
						"input", fmt.Sprintf("%#v", csample.Input))
				}
			}
		}
	}
	return nil
}

func (s *cmdSampler) cmdSamples(c *cobra.Command, cmdPath []string) error {

	cmdPath = append(append([]string{}, cmdPath...), c.Name())

	if c.RunE != nil {
		smpls, err := s.samplesFor(c, cmdPath)
		if err != nil {
			return err
		}
		if smpls != nil {
			s.samples = append(s.samples, smpls)
		}
	}

	for _, child := range c.Commands() {
		err := s.cmdSamples(child, cmdPath)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s *cmdSampler) examples(rootName string, c *Cmd) (int, int, int, []string) {
	withRun := 0
	withEx := 0
	exCount := 0
	if !c.RunE.IsNil() {
		withRun = 1
	}
	ex := strings.Split(string(c.Example), "\n")
	res := make([]string, 0, len(ex))
	for _, e := range ex {
		e = strings.Trim(e, "\r\t ")
		if strings.HasPrefix(e, rootName) {
			withEx = 1
			exCount++
			res = append(res, e)
		}
	}
	if withRun > 0 && withEx == 0 {
		s := fmt.Sprintf("Command '%s' has no example", c.Name())
		fmt.Println(s)
	}
	for _, sub := range c.SubCommands {
		wr, we, ec, rsub := s.examples(rootName, sub)
		withRun += wr
		withEx += we
		exCount += ec
		res = append(res, rsub...)
	}
	return withRun, withEx, exCount, res
}

// unquote json arg
func (s *cmdSampler) unquote(args []string) []string {
	for i, s := range args {
		if strings.HasPrefix(s, "'{") && strings.HasSuffix(s, "}'") {
			args[i] = s[1 : len(s)-1]
		}
	}
	return args
}

func (s *cmdSampler) ValidateExamples() error {

	// go through the app and replace the run func with our 'runSample'
	s.replaceRun(s.app.spec.CmdRoot, false)

	withRun, withEx, exCount, examples := s.examples(
		s.app.spec.CmdRoot.Name(),
		s.app.spec.CmdRoot)
	err := s.printer.ExamplesSummary(withRun, withEx, exCount)
	if err != nil {
		return err
	}
	if len(examples) == 0 {
		return nil
	}
	for _, ex := range examples {
		// construct the cobra commands
		root, err := s.app.NewCobra()
		if err != nil {
			return err
		}
		s.printer.Example(ex)
		os.Args = s.unquote(strings.Split(ex, " "))
		err = root.Execute()
		if err != nil {
			return errors.E("validate example", err, "example", ex,
				"args", strings.Join(os.Args, ","))
		}
	}
	return nil
}
